

 PICO-8 v0.1.8
 http://www.pico-8.com
 (c) Copyright 2014-2016 Lexaloffle Games LLP
 만든 이: Joseph White // hey@lexaloffle.com
 옮긴 이: Dinir Nertan // DinirNertan@gmail.com

  PICO-8은 아래의 기술로 만들어졌습니다:
  SDL2 http://www.libsdl.org
  Lua 5.2 http://www.lua.org // license.txt 를 참조
  GIFLIB http://giflib.sourceforge.net/
 

 



PICO-8에 오신 것을 환영합니다!

PICO-8은 작은 게임이나 다른 컴퓨터 프로그램을 만들고 공유하고 즐길 수 있는 가상 콘솔입니다.
기계를 켜면 즉석에서 루아 프로그램을 짤 수 있는 쉘이 나타납니다. 또한 스프라이트, 맵, 소리를 만들 수 있는 간단한 빌트인 툴도 제공합니다.

PICO-8의 가혹한 제한 사항은 작업에 재미를 부여하고, 작지만 다양한 것을 표현할 수 있는 디자인을 독려하며 또 PICO-8 카트리지가 나름의 독특한 외관과 느낌을 가질 수 있길 바라며 조심스럽게 고른 것입니다.


:: 키

전체화면 전환: Alt+Enter
나가기: Alt+F4 또는 command-Q
다시 불러오기/실행/카트 재시작: Ctrl+R
퀵 세이브: Ctrl+S
P: 일시정지 (실행 중일 때)
플레이어 1 기본 키: 화살표 키 + ZX / NM / CV
플레이어 2 기본 키: SDFE + 탭,Q / shift A
// KEYCONFIG 에서 기본 키를 변경할 수 있음


:: 스펙

디스플레이: 128x128, 고정 16색 팔레트
입력: 6버튼
카트리지 용량: 32k
소리: 4 채널, 64개의 정의 가능 음색
코드: 루아 (최대 8192개 토큰)
스프라이트: 단일 뱅크로 128개의 8x8 스프라이트 (+128개의 공유 스프라이트)
맵: 128x32 칸의 8-비트 셀 (+128x32 칸의 공유 맵)


:: Hello World

PICO-8을 부팅한 다음에, 다음의 명령어를 치고 엔터를 눌러보세요:

PRINT("HELLO WORLD")
RECTFILL(80,80,120,100,12)
CIRCFILL(70,90,20,14)
FOR I=1,4 DO PRINT(I) END

(참고: PICO-8에서는 대문자 영어만 표시합니다. 캡스 락을 키지 말고 평소처럼 쳐보세요!)

코드 편집 모드에서 이런 명령어들과 별도로 제공되는 두 개의 특별한 콜백 함수 _update, _draw 를 활용해서 대화형 프로그램을 만들 수 있습니다. 예를 들면, 아래의 프로그램은 커서 키를 통해 동그라미를 움직일 수 있게 해줍니다. ESC 키를 눌러 코드 편집기로 들어간 다음, 아래의 코드를 직접 입력하거나 복사 붙여넣기 해보세요:

X = 64  Y = 64
FUNCTION _UPDATE()
 IF (BTN(0)) THEN X=X-1 END
 IF (BTN(1)) THEN X=X+1 END
 IF (BTN(2)) THEN Y=Y-1 END
 IF (BTN(3)) THEN Y=Y+1 END
END

FUNCTION _DRAW()
 RECTFILL(0,0,127,127,5)
 CIRCFILL(X,Y,7,8)
END

이제 ESC를 다시 눌러 메인 콘솔 화면으로 돌아와서, RUN 을 입력해서 실제로 작동되는 모습을 보세요.
더 복잡한 프로그램을 받고 싶으시다면 예제 카트리지를 참조하세요.


:: 예제 카트리지

아래의 카트리지들은 PICO-8에 포함되어 있으며 다음의 명령어를 통해 설치할 수 있습니다:
INSTALL_DEMOS
CD DEMOS

API        PICO-8에서 지원하는 함수 대부분에 대한 데모
JELPI      2인 플레이를 지원하는 플랫폼 게임 데모
CAST       2.5D 레이캐스터 데모
MANDEL     만델브로트 탐색기
COLLIDE    벽-캐릭터 간 충돌 예제
BUTTERFLY  시에르핀스키 삼각형
DRIPPY     흘러내리는 선 그리기
STOMPY     음악 카트리지
WOO        음악 카트리지

카트리지를 실행하기 위해서는, PICO-8을 열고 다음과 같이 입력합니다:

LOAD JELPI
RUN

ESC를 눌러서 프로그램을 멈추고, 한 번 더 눌러서 편집 모드로 들어가보세요.


:: 파일시스템

다음의 명령어를 통해 파일과 디렉터리(폴더)를 관리할 수 있습니다:

DIR        현재 디렉터리의 내용을 표시
CD BLAH    디렉터리 변경
CD ..      상위 디렉터리로 이동
CD /       (PICO-8 가상 드라이브 내의) 최상위 디렉터리로 이동
MKDIR      디렉터리 생성
FOLDER     현재 디렉터리를 호스트 OS의 파일 브라우저에서 열기

LOAD BLAH  현재 디렉터리에서 카트 불러오기
SAVE BLAH  현재 디렉터리에 카트 저장하기

파일을 옮기거나 복사 또는 삭제를 해야 할 경우엔, FOLDER 명령어를 통해서 호스트 OS 내에서 하는 것이 좋습니다.

PICO-8의 기본 위치는 아래와 같습니다:

Windows: C:/Users/사용자이름/AppData/Roaming/pico-8/carts
OSX: /Users/사용자이름/Library/Application Support/pico-8/carts
Linux: ~/.lexaloffle/pico-8/carts

기본 위치와 기타 설정을 pico-8/config.txt에서 변경할 수 있습니다.

팁: Dropbox를 사용하시는 분이라면, 드라이브 위치를 Dropbox 공유 폴더 내에 설정하여 하나의 디스크를 여러 대의 컴퓨터에 설치된 PICO-8에 제공할 수 있습니다.


:: 백업

변경 사항을 저장하지 않고 나갔을 경우나 존재하는 파일을 덮어씌웠을 경우, pico-8/backup에 해당 카트리지의 백업이 생성됩니다.


:: 설정

:: config.txt

config.txt에서 몇 가지 설정을 찾아볼 수 있습니다. PICO-8을 실행하지 않은 상태에서 수정하세요.

Windows: C:/Users/사용자이름/AppData/Roaming/pico-8/config.txt
OSX: /Users/사용자이름/Library/Application Support/pico-8/config.txt
Linux: ~/.lexaloffle/pico-8/config.txt

-home 스위치(아래 참조)를 이용해서 config.txt를 비롯한 데이터를 다른 경로에 저장하세요.


:: 커맨드라인 파라미터

// 참고: 아래의 파라미터는 config.txt 에 저장된 세팅보다 우선함

pico-8 [스위치] [파일이름.p8]

-run                실행과 동시에 파일이름.p8을 구동
-width n            윈도우나 화면의 너비를 정하고 스케일이 지정되지 않았을 경우 화면에 맞게 스케일을 조정
-height n           윈도우나 화면의 높이를 정하고 스케일이 지정되지 않았을 경우 화면에 맞게 스케일을 조정
-scale n            PICO-8에서 표시할 픽셀의 스케일 조정. "-scale 3" 을 입력하면 각각의 픽셀을 3x3 사이즈로 표시
-windowed n         창모드를 끄거나(0) 켜기(1)
-sound n            소리 크기 0..256
-music n            음악 크기 0..256
-joystick n         조이스틱 컨트롤을 n 번째 플레이어의 입력으로 받아들입니다 (0..7)
-aspect n           화면 비율 설정. 420 = 1:1(기본), 560 = 4:3, 525 = 5:4.
-run filename       자동으로 해당 카트리지를 불러서 구동
-splore             splore 모드로 실행
-home path          config.txt를 비롯한 다른 사용자 데이터를 저장할 경로를 설정
-gif_len n          최대 gif 길이를 초 단위로 설정 (1..120)


:: 컨트롤러 설정

PICO-8은 SDL2 컨트롤러 스키마를 사용합니다. 구동 시에 알려진 컨트롤러를 감지하고, config.txt가 있는 폴더에 들어있는 sdl_controllers.txt에 커스텀 맵핑이 있는지 또한 찾아봅니다 sdl_controllers.txt 는 한 줄에 한 개의 맵핑을 담고 있습니다.

사용하시는 컨트롤러를 위한 커스텀 맵핑을 만드시려면, SDL2에 딸려오는 컨트롤맵 프로그램을 쓰거나, 여기를 활용해보세요. http://www.generalarcade.com/gamepadtool/

 키보드 키의 맵핑을 변경하시려면, KEYCONFIG 명령어를 사용하세요.


:: 카트리지 공유하기 / HTML5로 내보내기

카트리지를 공유하는 방법은 세 가지가 있습니다:

1. .p8 이나 .p8.png 파일을 다른 PICO-8 사용자와 직접 공유하기

2. Lexaloffle 게시판에 올려 웹 버전을 얻기

http://www.lexaloffle.com/pico-8.php?page=submit

save() 를 참조하여 어떻게 .p8.png 를 만드는지 알아보세요. (.png로 검색)

3. 카트리지를 스탠드얼론 HTML5 버전으로 내보내기:

EXPORT FOO.HTML

이 명령어를 실행하면 두 개의 파일이 만들어집니다: foo.html과 foo.js (둘 다 필요합니다!)

추출한 카트리지의 배포와 사용은 제작자와 기여자의 허가 아래에 자유롭게 사용할 수 있습니다.

.html 파일은 자유롭게 수정 가능한 기본 템플릿으로서 만들어졌습니다. 설정을 조정할 수 있는 버튼 몇 개와 외부 사이트 링크 (기본적으로 PICO-8 게시판) 를 포함하며, 게임 플레이 중에 화면이 스크롤되는 것을 막기 위한 자바스크립트 코드도 포함되어 있습니다.

플레이어의 너비와 높이 또한 조절할 수 있지만, 보통 화면이 표시되는 캔버스 크기에 맞추어야 한다는 점을 참고하세요 (기본값은 580,540).


:: 스크린샷, 비디오, 카트리지 라벨

카트리지를 실행 중일 때 사용해보세요:

F6 바탕화면에 스크린샷을 저장
F7 카트리지 라벨 이미지를 캡쳐
F8 비디오 녹화 시작
F9 바탕화면에 GIF 비디오를 저장 (최대: 기본값 8초)

// F6..F9를 사용할 수 없다면 F1..F4를 사용

카트리지 라벨은 save() 를 사용해서 p8.png로 저장할 때 저장됩니다.

비디오 저장은 아무때나 할 수 있습니다 (항상 녹화중입니다) -- F8을 누르면 녹화 시작 시점을 리셋해서 8초 이하의 비디오를 얻을 수 있습니다.

GIF의 최대 길이를 바꾸려면, config.txt의 gif_len 값을 원하는 초 단위의 숫자로 바꿔주세요. GIF 형식에선 30fps를 정확하게 맞출 수 없기 때문에, PICO-8에서는 대신 가장 근사한 값인 33.3fps를 사용합니다.


:: 내보내기 / 가져오기

1. 스프라이트 시트를 .png 형식으로 가져오거나 내보내려면:

import("blah.png")    --  128x128 의 pico-8 팔레트에 맞춘 png 파일로 가져옴
export("blah.png")    --  추출한 png를 확인하려면 folder()를 사용

2. 효과음이나 음악을 추출하려면:

export("blah.wav")    --  현재 패턴의 음악을 내보내기(음악 편집 모드일 때)
export("blah.wav")    --  현재 SFX를 내보내기(SFX 편집 모드일 때)
export("blah%d.wav")  --  모든 SFX를 blah0.wav, blah1.wav .. blah63.wav 로 내보내기

// 명령어 입력 창에서는 괄호와 따옴표를 생략할 수 있음: EXPORT BLAH.WAV 


:: PICO-8의 특징

주의해야 할 알려진 특징들:

- 스프라이트 시트와 맵의 아래쪽 절반은 같은 메모리를 차지합니다.
// 어떤 말인지 모르겠다면 아래쪽 절반은 한 쪽에서만 사용할 것
- PICO-8에서 숫자는 32767.99까지만 올라갑니다.
// 매 프레임마다 1씩 올라가는 카운터를 실항하면, 약 18분 후에 오버플로우가 발생함!
- Lua 배열은 기본적으로 0-based가 아닌 1-based입니다. FOREACH 는 T[0]이 아닌 T[1]부터 시작합니다.
- cos()와 sin()는 0..PI*2 대신 0..1 값을 받습니다. 또한 sin()는 뒤집힌 위상 값을 출력합니다.
- sgn(0) 은 1을 출력합니다.
- 전체화면 전환: OSX에서는 alt-enter를 사용하세요 (command-F 는 텍스트 검색에 쓰입니다).
- .png 형식으로 카트리지를 추출하려면, EXPORT말고 SAVE를 사용하세요. EXPORT는 스프라이트 시트만을 저장합니다!


:: Splore

SPLORE는 로컬 공간이나 게시판(온라인)에서 카트리지를 찾아서 정리할 수 있게 해주는 빌트인 도구입니다. SPLORE [enter]로 실행하거나, PICO-8에 -splore를 붙여서 실행하세요.

SPLORE를 컨트롤러로만 조작하는 것도 가능합니다:
LEFT와 RIGHT로 카트리지 리스트를 바꾸기
UP과 DOWN으로 리스트 안의 항목을 선태
X,O 나 MENU로 카트리지를 실행

카트리지 실행 중에 MENU를 눌러서 즐겨찾기에 추가하거나 splore로 나가세요.
키보드를 사용할 때는 카트리지 리스트에서 F를 눌러, 선택된 카트리지를 즐겨찾기에 추가할 수도 있습니다.

게시판 카트리지 리스트에서 최상위 항목을 선택해 리스트를 갱신하세요. 오프라인 상태일 경우는 마지막으로 갱신된 리스트가 나타나며, 다운로드한 카트리지를 플레이할 수 있습니다.

인터넷 접근이 불가능한 기계에 PICO-8을 설치했을 경우에도, INSTALL_GAMES 를 통해 사전에 설치된 게시판 카트리지 일부를 즐겨찾기 목록에 추가할 수 있습니다.


============================================================================================
편집 모드
============================================================================================

ESC를 눌러서 콘솔과 편집기 사이를 전환하세요
우측 상단의 편집 모드 탭을 클릭하거나 ALT+LEFT/RIGHT로 편집 모드 사이를 전환하세요

** 경고: 스프라이트 시트의 절반 (뱅크 2, 3)과 맵의 아래쪽 절반은 카트리지 내에서 같은 공간을 씁니다. 이 공간을 어떻게 쓸지는 당신의 자유지만, 한쪽을 편집하면서 그린 내용이 다른 쪽에 처참한 영향을 끼칠 수 있음을 염두해두시기 바랍니다


:: 코드 편집기

shift를 누른 채로 선택 (혹은 마우스로 클릭해서 드래그)
CTRL-X, C, V 선택 영역을 자르거나 복사하고 붙여넣기
CTRL-Z, Y 취소, 재실행
CTRL-F 문자열 검색
CTRL-G 이전 검색을 반복
ALT-UP, DOWN 이전/다음 함수로 이동

코드 편집기의 우측 하단에서 토큰 사용량을 확인할 수 있습니다. 하나의 프로그램은 최대 8192개의 토큰을 가질 수 있습니다. 각 토큰은 단어(변수 명) 혹은 오퍼레이터일 수 있습니다. 괄호 쌍이나 문자열은 1개의 토큰으로 취급합니다. 쉼표, 마침표, LOCAL, 세미콜론, END, 주석은 토큰으로 취급하지 않습니다.

버튼을 의미하는 특수기호를 입력하려면 SHIFT-L,R,U,D,O,X를 사용하세요.


:: 스프라이트 편집기

스프라이트 편집기는 스프라이트 수준의 편집이나 픽셀 수준의 편집 모두에 사용될 수 있게 만들어졌습니다. 화면 아래의 내비게이터는 스프라이트시트를 8x8 단위로 볼 수 있게 해주며, 또한 자유형태freeform 도구(pan, select)을 이용하면 더 큰 지역을 편집할 수 있습니다.

그리기 도구
클릭과 드래그로 편집
보여지는 영역에 적용
CTRL을 눌러 색을 찾아 바꾸기
마우스 왼쪽 버튼으로 색을 선택

스탬프 도구
스탬프 안에 저장된 것을 찍어내기
LCONTROL을 눌러 투명도를 반영해 찍기

선택 도구 // 단축키: LSHIFT, S
선택 영역 만들기
Enter나 클릭으로 선택 취소

픽셀 수준의 선택 영역이 없을 경우, 대부분의 작업은 스프라이트 수준의 선택 영역에 적용됩니다. 스프라이트를 선택하려면, 스프라이트 내비게이터에서 shift-드래그를 하세요.

팬 도구 // 단축키: space
스프라이트 시트 보기

채우기 툴
현재 선택 색상으로 채우기
현재 선택 영역에 적용
선택 영역이 없을 경우, 보여지는 영역에 적용

추가 키
CTRL-Z 취소 // 0.2.0 현재 한 단계만 가능
CTRL-C 선택 영역이나 스프라이트 복사
CTRL-V 현재 스프라이트 위치에 붙여넣기
Q,W 이전/다음 스프라이트로
1,2 이전/다음 색으로
Tab 전체화면 보기로 전환
Mousewheel 확대/축소 (전체화면에선 가운데 지점을 기준으로 적용)


선택 영역/스프라이트에 대한 작업
f 뒤집기
v 상하로 뒤집기
r 회전(선택 영역이 정사각형이어야 함)
커서 키로 이동 (선택이 스프라이트일 경우 순환)

스프라이트 플래그
8개의 원은 현재 스프라이트에 대한 스프라이트 플래그를 나타냅니다.
각각 true(on) 또는 false(off) 상태를 지닐 수 있으며, FSET, FGET 함수를 통해 이들 값에 접근할 수 있습니다. 플래그의 번호는 왼쪽부터 0,1,2..7 입니다. fset() 항목을 참조하세요.


:: 맵 편집기

pico-8 맵은 128x32 (혹은 공유 공간을 포함했을 경우 128x64) 개의 8비트 값 블록으로 이루어져 있습니다.
각각의 값은 편집기에서 스프라이트(0..255)로 표시됩니다. 이 값들로 어떤 것을 표시할 것인가는 물론 당신의 자유입니다.

맵 편집기에서 제공하는 도구들은 스프라이트 편집기와 유사합니다. 스프라이트를 선택한 다음 클릭하고 드래그해서 맵에 값을 칠하세요.

여러 개의 스프라이트를 그리려면, 스프라이트 내비게이터에서 shift+드래그로 블록을 만들어 선택하세요.
블록 단위로 값을 복사하려면, 선택 도구를 쓴 다음 스탬프 도구를 써서 붙여넣으세요.
맵 주변을 둘러보려면, 팬 도구를 쓰거나 space를 누르세요.
Q,W 로 이전/다음 스프라이트를 볼 수 있습니다.


:: SFX 편집기

한 카트리지에는 64개의 SFX("효과음")을 담을 수 있습니다. 효과음으로 혹은 음악으로 쓸 수 있습니다.

각 SFX는 32개의 노트를 가지며, 각각의 노트는 다음의 구성 요소를 갖습니다:
주파수 (C0..C5)
악기   (0..7)
볼륨   (0..7)
효과   (0..7)

각 SFX는 다음과 같은 속성도 가집니다:

재생 속도 (SPD) : 각 노트를 플레이하는데 걸리는 '틱'의 수입니다.
// 1 은 빠르고, 3은 1보다 3배 느림

루프의 시작과 끝 : 반복해서 재생할 구간의 시작과 끝 인덱스를 나타냅니다.
// 시작 인덱스 >= 끝 인덱스 일 때 루프는 꺼짐

SFX를 수정/확인할 수 있는 모드는 2가지가 있습니다: 피치 모드(효과음 편집에 적합) 와 트래커 모드(음악 편집에 적합)입니다. 이 모드는 화면 좌측 상단 버튼 또는 TAB을 눌러서 바꿀 수 있습니다.


1. 피치 모드

피치 영역을 클릭하고 드래그하여 각 노트에 대한 주파수를 설정하세요. 현재 설정된 악기는 각 노트의 색으로 표시됩니다.

shift를 누른 채로 현재 악기만 적용하세요.
CTRL을 눌러서 노트를 C 마이너 펜테토닉 스케일에 맞추세요.


2. 트래커 모드

각 노트의 구성 요소는 다음과 같습니다: 주파수 옥타브 악기 볼륨 효과
노트를 입력하려면 q2w3er5t6y7ui zsxdcvgbhnjm (피아노 레이아웃) 를 누르세요.
새로운 노트에는 현재 선택된 악기/효과 값이 배정됩니다.
노트를 지우려면 backspace를 누르거나 볼륨을 0으로 맞추세요.

클릭, shift-클릭으로 영역을 선택해서 복사(CTRL-C)하거나 붙여넣을(CTRL-V) 수 있습니다.


3. 공통 컨트롤

- + SFX 간 이동
< > 속도 변경
SPACE 재생/멈춤
A 루프 중인 샘플의 루프 풀기
클릭 또는 왼쪽 클릭 SPD값과 LOOP값의 증가/감소
 // Shift를 누른 채로 조작하면 4 단위로 증가/감소
 // 또는, 클릭한 채로 좌/우 혹은 상/하로 드래그해서 조작
Shift-클릭 모든 노트에 동일한 악기, 효과 또는 볼륨을 적용


:: 효과

0 없음
1 슬라이드         //  현재 노트로 슬라이드
2 비브라토         //  1/4톤 범위에서 피치 떨기 
3 드랍             //  노트 주파수를 빠르게 떨어뜨림
4 페이드 인        //  볼륨을 0에서부터 올림
5 페이드 아웃      //  볼륨을 0으로 줄임
6 빠른 아르페지오  //  4 속도로 4개의 노트를 순환
7 느린 아르페지오  //  8 속도로 4개의 노트를 순환

SFX 속도 <= 8일 경우, 아르페지오 스피드는 각각 2, 4로 줄어듭니다.

:: 음악 편집기

PICO-8에서 음악은 '패턴'의 연속으로 관리됩니다. 각 패턴은 한 개의 SFX를 재생할 수 있는 채널 네 개로 구성됩니다.


:: 순서 조절

재생 순서는 우측 상단의 3개의 버튼을 통해 조절할 수 있습니다.

패턴의 재생이 끝나면, 아래의 조건에 해당하지 않는 경우 다음 패턴을 재생합니다:

- 남은 패턴이 없음 (음악 멈춤)
- STOP 명령이 현재 패턴에 설정되어 있음 (3번째 버튼)
- LOOP BACK 명령이 현재 패턴에 설정되어 있음 (2번째 버튼): 이 경우 음악 재생기는 LOOP START 버튼 (1번째 버튼) 이 설정된 패턴 혹은 해당 패턴이 없을 경우 0번 패턴으로 돌아가 재생을 계속함

패턴 내에 속도가 다른 SFX가 있을 경우, 순환하지 않는 가장 왼쪽 패턴의 재생이 끝날 때 패턴의 재생이 끝나게 됩니다. 변칙 박자나 더블타임 드럼 비트 등을 설정할 때 사용할 수 있습니다. (더블 타임: 같은 리듬을 속도만 두 배 빠르게 해서 연주하는 것)


:: 음악 복사하기

여러 개의 패턴을 선택하려면: 패턴 내비게이터에서 처음 패턴을 클릭해서 선택하고, 마지막 패턴을 shift-클릭으로 선택합니다. 선택한 패턴은 CTRL-C와 CTRL-V를 사용해서 복사하고 붙여넣을 수 있습니다. 다른 카트리지에 붙여넣을 때는 필요할 경우 패턴이 참조하는 SFX들도 같이 복사될 것입니다 (이 때 인덱스 번호가 달라질 수 있습니다). 

============================================================================================
Lua 문법 입문서
============================================================================================

PICO-8 프로그램은 Lua 문법으로 작성되었습니다만, 표준 Lua 라이브러리를 사용하지는 않습니다. 다음은 필수적인 Lua 문법에 대한 간략한 요약입니다.

더 자세히 알아보고 싶으시거나 제대로 된 Lua에 대해 알아보고 싶으시다면 http://www.lua.org 를 참조하세요.

:: 코멘트

-- 하이픈을 두 개 써서 줄이 끝날 때까지의 모든 문자를 무시
--[[ 여러 줄로 된
코멘트 ]]


:: 타입types과 할당assignment

Lua에 존재하는 타입은 수numbers, 문자열strings, 불 대수booleans, 테이블tables이 있습니다.

NUM = 12/100
S = "THIS IS A STRING"
B = FALSE
T = {1,2,3}

PICO-8에서 쓰이는 모든 숫자는 가수부:지수부가 16:16인 고정소수점 방식으로 표시되며, -32768.0 ~ 32767.99 의 범위를 갖습니다.

16진수와 fractional parts를 병행한 표기를 사용할 수 있습니다:
0x11        -- 17
0x11.4000   -- 17.25

0으로 나누면 가장 큰 숫자로 받아들입니다: 0x7fff.ffff


:: 조건문conditionals

IF NOT B THEN              -- B가 아닐 경우
PRINT("B IS FALSE")      -- "B는 거짓" 이라고 출력
ELSE                       -- 그렇지 않을 경우
PRINT("B IS NOT FALSE")  -- "B는 거짓이 아님" 이라고 출력
END                        -- 조건문 끝

-- ELSEIF와 함께 쓰일 경우

IF X == 0 THEN                            -- X가 0일 경우
PRINT("X IS 0")                         -- "X는 0" 이라고 출력
ELSEIF X < 0 THEN                         -- 그렇지 않고 X가 0보다 작을 경우
PRINT("X IS NEGATIVE")                  -- "X는 음수" 라고 출력 
ELSEIF X > 0 THEN                         -- 그렇지 않고 X가 0보다 클 경우
PRINT("X IS POSITIVE")                  -- "X는 양수" 라고 출력 
ELSE                                      -- 그렇지 않을 경우
PRINT("THIS IS LINE IS NEVER REACHED")  --[[ "이 줄은 실행되지 않음" 라고 출력
                                        (이 줄을 실행할 수 있는 조건을 만족하는 X 가 없습니다) ]]
END                                       -- 조건문 끝

IF (4 == 4) THEN PRINT("EQUAL") END
-- 4가 4일 경우, "같음" 이라고 출력
IF (4 ~= 3) THEN PRINT("NOT EQUAL") END
-- 4가 3이 아닐 경우, "같지 않음" 이라고 출력
IF (4 <= 4) THEN PRINT("LESS THAN OR EQUAL") END
-- 4가 4와 같거나 더 적을 경우, "작거나 같음" 이라고 출력
IF (4 > 3) THEN PRINT("MORE THAN") END
-- 4가 3보다 클 경우, "더 큼" 이라고 출력

:: 반복문loops

FOR X=1,5 DO         -- X가 1에서 5까지의 값을 취할 때에 실행
PRINT(X)           -- X를 출력
END                  -- 반복문 끝
                     -- 1,2,3,4,5를 출력

X = 1
WHILE(X <= 5) DO  -- X가 5보다 작거나 같을 때에 실행 
PRINT(X)        -- X를 출력
X = X + 1       -- X의 값을 1 증가
END               -- 반복문 끝

FOR X=1,10,3 DO PRINT(X) END   -- 1,4,7,10

FOR X=5,1,-2 DO PRINT(X) END  -- 5,3,1


:: 함수functions와 지역 변수local variables

Y=0
FUNCTION PLUSONE(X)  -- PLUSONE이라는 함수 생성, 인자값으로 X를 받는다
LOCAL Y = X+1      -- 함수 내에서만 사용할 지역변수 Y에 X+1의 값을 할당
RETURN Y           -- 이 함수는 Y를 반환
END                  -- 함수 끝
PRINT(PLUSONE(2)) -- 3
PRINT(Y)          -- 0
-- Y는 함수 내에서만 선언된 변수이므로 함수 바깥에서 접근하면 찾을 수 없음


:: 테이블tables

Lua에서 테이블은 여러 키-값 쌍들의 모임이며, 이 때 키와 값의 타입은 혼용해서 쓸 수 있습니다. 정수 인덱스에 접근해서 배열처럼 사용할 수 있습니다.

A={} -- 빈 테이블 생성
A[1] = "BLAH"
A[2] = 42
A["FOO"] = {1,2,3}

-- 배열은 기본적으로 1-based 인덱스를 사용 (배열 내 할당된 첫번째 값의 주소를 1부터 지정한다는 뜻입니다).

A = {11,12,13,14}
PRINT(A[2]) -- 12

-- 연속된 네 개의 1-based 정수로 인덱스가 지정된 테이블의 사이즈

PRINT(#A)   -- 4

-- 인덱스가 문자열인 경우 dot notation으로 접근할 수 있습니다.

PLAYER = {}
PLAYER.X = 2 -- PLAYER["X"] 로도 접근 가능
PLAYER.Y = 3

-- 아래 api 참조에서 테이블 섹션을 참조하세요.


:: PICO-8 속기

PICO-8은 흔히 쓰이는 패턴에 대해 비표준적인 더 짧은 표기 방법을 허용합니다.

1. IF THEN END 문장을 한 줄에 쓸 때 THEN과 END를 생략할 수 있습니다.

IF (NOT B) I=1 J=2

-- 다음의 코드와 동일: IF (NOT B) THEN I=1 J=2 END
-- 조건을 둘러싸는 괄호는 반드시 필요

2. 단항 수식 연산자

a += 2  -- 다음의 코드와 동일: a = a + 2
a -= 2  -- 다음의 코드와 동일: a = a - 2
a *= 2  -- 다음의 코드와 동일: a = a * 2
a /= 2  -- 다음의 코드와 동일: a = a / 2
a %= 2  -- 다음의 코드와 동일: a = a % 2

3. != 연산자

속기 표기는 아니지만, pico-8에서는 ~= 대신 !=도 "같지 않음"을 뜻하는 연산자로 사용할 수 있습니다.


============================================================================================
API
============================================================================================

PICO-8은 Lua 스크립트 언어를 기반으로 만들어졌지만, 표준 라이브러리를 사용하지는 않습니다. 대신 PICO-8의 미니멀한 디자인과 제한된 화면 사이즈를 활용할 수 있도록 작은 api를 제공하고 있습니다. api 사용 예제 프로그램을 보려면 /DEMOS/API.P8 을 참ㅈ하세요.

함수는 다음과 같은 형식으로 표기합니다.
function_name parameter [optional_parameter]
-- 함수_이름 인자 [선택적_인자]

시스템 함수를 명령줄에서 부를 때는 괄호와 따옴표를 생략할 수 있습니다.
load blah.p8 --> load("blah.p8")


--------------------------------------------------------------------------------------------------------
시스템
--------------------------------------------------------------------------------------------------------


load filename
save filename
카트리지를 불러오거나 저장합니다.

".png" 형식을 사용해서 png 파일로 저장하세요 -- 그렇지 않을 경우 텍스트 형식 (".p8")으로 저장합니다.

".p8"은 생략할 수 있으며, 명령을 실행할 때 자동으로 추가됩니다.
save("blah") --> save("blah.p8")
save("blah.png") --> save("blah.p8.png")
load("blah.png") --> load("blah.p8.png") (blah.png가 존재하지 않을 경우)

불러올 때도 마찬가지입니다. 파일을 찾을 수 없을 경우 pico-8은 ".p8"을 붙여서 다시 시도합니다.

".png"는 불러올 때에 한해서 생략할 수 있습니다.
load ("blah") --> "blah.p8"이 없을 경우 "blah.p8.png"를 찾고 이도 없을 경우 "blah.png"를 찾습니다.

카트리지를 한 번 이상 불러오거나 저장했을 경우, CTRL-S 로 퀵세이브를 할 수 있습니다.


:: 텍스트 라벨과 미리보기 이미지가 들어간 .png 카트리지로 저장하기

카트리지에 저장될 미리보기 이미지를 만들려면, 프로그램을 실행한 다음 F7을 눌러서 화면을 캡쳐하세요. 프로그램 코드의 첫 두 줄에 쓴 코멘트가 카트리지의 라벨로 쓰여집니다.

e.g.
-- OCEAN DIVER LEGENDS
-- BY LOOPY


:: .png 형식의 코드 사이즈 제한

.png 형식으로 저장할 때, 압축된 코드의 크기는 반드시 15360 바이트 이내여야 합니다. 현재 코드 사이즈를 보려면 INFO 명령어를 사용하세요. 압축 사이즈 제한은 .p8 포맷에서는 적용되지 않습니다. 대부분의 경우 압축 코드 사이즈에 대해서 고려해야 할 필요는 없을 것입니다. 크기가 커진 코드는 8192 토큰 제한에 보통 먼저 도달하기 때문입니다.


folder
호스트 OS 에서 카트리지가 들어있는 폴더를 열기

ls
현재 폴더의 모든 파일을 열거해서 보이기

run
프로그램을 시작 지점에서부터 실행
프로그램 내부에서 리셋 목적으로 호출할 수 있음

resume
현재 카트리지 상태에서 프로그램을 실행 (문제가 발생할 수 있습니다).

reboot
기계를 재부팅
새로운 프로젝트를 시작할 때 쓸 수 있음

stat x
x:0 현재 Lua 메모리 사용량을 출력 (0..1024MB)
x:1 마지막 프레임에서의 CPU 사용량을 출력 (1.0은 30fps 속도에서 100% 사용량을 의미)

info
현재 카트리지에 대한 정보 출력:
코드 사이즈, 토큰, 압축 사이즈

flip
백 버퍼back buffer를 스크린으로 넘기고 다음 프레임까지 대기 (30fps)
보통 직접 이 명령어를 호출할 일은 없음 -- _draw()가 대신 이 명령어를 호출함

프로그램에서 프레임을 올리기 전에 flip을 호출하지 않았고, _draw() 함수가 아직 실행중이지 않을 경우, 백 버퍼에 담긴 현재 콘텐츠가 화면에 표시됩니다.

printh str
디버그 목적으로 문자열을 호스트 OS의 콘솔에 출력


--------------------------------------------------------------------------------------------
프로그램 구조
--------------------------------------------------------------------------------------------

다음의 특별 함수 3개는 사용자가 선언했을 경우 프로그램 실행 중에 호출됩니다:

_update()
30fps에서 매 업데이트 시기마다 호출

_draw()
매 번 프레임을 보여야 할 때마다 호출

_init()
프로그램을 시작할 때 호출

_draw()는 보통 30fps의 속도로 호출됩니다. 하지만 제 시간 안에 이 함수가 제 작업을 다 끝내지 못할 경우, pico-8은 프로그램을 15fps의 속도로 낮춰 돌리는 대신 _update() 함수를 매 프레임이 보여지는 간격 당 두 번 씩 호출할 것입니다.



:: PICO-8을 60fps로 구동하기

_update() 대신 _update60()을 선언할 경우, PICO-8은 60fps 모드로 구동됩니다:

- _update60()과 _draw()는 60fps의 속도로 호출됩니다.
- 30fps로 속도가 떨어지기 전까지 PICO-8 CPU의 절반만을 매 프레임에서 사용할 수 있습니다.

** 모든 PICO-8이 60fps를 지원하진 않습니다. 지원하지 않는 기기에서는 _update60()이 프레임 당 두 번 씩 호출되고 _draw()는 30fps의 속도로 호출됩니다. 30fps 환경에서 구동할 때의 프로그램 작동 모습을 보고 싶을 경우 코드의 아래에 다음을 추가하세요:

u60=_update60 _update60=nil function _update() u60() u60() end


--------------------------------------------------------------------------------------------
그래픽
--------------------------------------------------------------------------------------------

PICO-8은 128개의 8x8 스프라이트를 담고 있는 한 개의 뱅크와, 맵의 하단부 절반과 공유하는 128개의 공유 데이터를 갖고 있습니다. 이 256개의 스프라이트를 스프라이트 시트sprite sheet라 부르며, 128x128 사이즈의 픽셀 이미지라고 볼 수도 있습니다.

PICO-8의 모든 그리기 작업은 현재 그리기 상태의 영향을 받습니다. 이 상태는 카메라 포지션 (모든 좌표에 오프셋을 설정할 때), 팔레트 매핑(스프라이트 색깔을 다시 칠할 때), 선택한 사각형, 함수의 호출을 통해 임의로 지정되는 경우를 제외하면 항상 고정되어 있는 현재 선택한 색 등을 포함합니다.

그리기 상태는 프로그램이 실행될 때마다 리셋됩니다. 이것은 다음을 호출하는 것과 같습니다:
clip() camera() pal() color()

컬러 인덱스:

 0  검정    1  어두운파랑  2  어두운보라    3  어두운초록  
 4  갈색    5  어두운회색   6  밝은회색      7  하양
 8  빨강    9  주황       10  노랑         11  초록       
12  파랑   13  남색       14  분홍         15  복숭아색


clip [x y w h]

스크린의 클리핑 경계를 픽셀로 정의
clip()으로 호출해서 리셋


pget x y
pset x y [c]

x, y 지점 픽셀의 색깔을 추출하거나 c로 바꿉니다.


sget x y
sset x y [c]

스프라이트시트 상의 x, y 지점 픽셀의 색깔을 추출하거나 c로 바꿉니다.


fget n [f]
fset n [f] v

스프라이트의 플래그 값을 가져오거나 v로 설정
f 플래그 인덱스 0..7
v 불 대수 값으로서 true 혹은 false

플래그의 초기 상태는 스프라이트 편집기의 여러 개의 작은 알록달록한 버튼 한 줄에서 설정할 수 있습니다.

스프라이트 플래그의 의미는 사용자의 의도에 따라 달라질 수 있습니다. 이를테면 어떤 그룹('레이어')의 스프라이트가 맵에 그려져야 하는지 등을 지시하기 위해 쓸 수 있을 것입니다.

플래그 인덱스가 생략되었을 경우, 모든 플래그는 비트필드의 형태로 전달/설정됩니다.
fset(2, 1+2+8)   -- 비트 0,1,3을 설정
fset(2, 4, true) -- 비트 4를 설정
print(fget(2))   -- 27 (1+2+8+16)


print str [x y [col]]

문자열을 출력
문자열만 인자로 입력했을 경우, 커서가 화면 끝에 다다르면 자동으로 캐리지 리턴을 적용하고 화면을 아래로 스크롤합니다. (터미널처럼 반응)


cursor x y

커서 위치와 캐리지 리턴 여백을 설정


color col

그리기 함수가 기본으로 사용할 색을 설정


cls

화면 지우기


camera [x y]

모든 그리기 함수에 -x, -y의 오프셋을 지정
camera()로 호출해서 리셋


circ     x y r [col]
circfill x y r [col]

x,y 지점에 r의 반지름을 갖는 (색칠된) 원 그리기


line x0 y0 x1 y1 [col]

선 그리기


rect     x0 y0 x1 y1 [col]
rectfill x0 y0 x1 y1 [col]

(색칠된) 직사각형 그리기


pal c0 c1 [p]

호출 시점 이후부터 모든 그리기 함수에서 c0 색 대신 c1 색을 사용 (컬러 리매핑)

pal()로 호출하여 투명값을 포함해 시스템 기본값으로 리셋
팔레트 종류 두 가지(p; 기본값은 0)
0 그리기 팔레트  : 새로 그릴 색들에 적용           // e.g. 스프라이트 컬러 리매핑
1 스크린 팔레트  : 화면에 보이는 색들에 적용       // e.g. 페이드 효과
c0 컬러 인덱스 0..15
c1 새로 적용할 컬러 인덱스


palt c t

컬러 인덱스의 투명도를 t(불 대수 값)로 적용
투명도의 적용 상태는 spr(), sspr(), map() 에서 확인 가능
e.g. palt(8, true) -- 빨간 색을 그리지 않음
palt()로 호출하여 기본값으로 리셋: 0번 색을 제외한 모든 색을 불투명하게



spr n x y [w h] [flip_x] [flip_y]

n (0..255) 번째 스프라이트를 x,y 위치에 그리기
너비와 높이의 기본값은 1,1
w, h 값을 통해 스프라이트 시트의 이웃하는 몇 칸까지 통째로 그릴 것인지를 결정
0번 색은 기본적으로 투명하게 그려짐 (palt()를 참조)
flip_x=true 좌우 뒤집기
flip_y=true 상하 뒤집기


sspr sx sy sw sh dx dy [dw dh] [flip_x] [flip_y]

스프라이트 시트의 (sx, sy)에서 가로 세로 (sw, sh)까지의 영역을 가져와서
화면의 (dx, dy)에서 가로 세로 (dw, dh)까지 늘려서 그리기 // 수치는 픽셀 단위
0번 색은 기본적으로 투명하게 그려짐 (palt()를 참조)
dw, dh는 명시되지 않았을 경우 sw, sh와 동일한 값
flip_x=true 좌우 뒤집기
flip_y=true 상하 뒤집기


--------------------------------------------------------------------------------------------
테이블
--------------------------------------------------------------------------------------------


add t v

테이블 t의 끝에 v를 값으로 추가합니다.
다음과 같음: t[#t+1] = v

FOO={}        -- 빈 테이블 만들기
ADD(FOO, 11)
ADD(FOO, 22)
PRINT(FOO[2]) -- 22

del t v

테이블 t에서 처음으로 찾아낸 v 값을 제거
테이블 안에 공백이 생기는 걸 막기 위해 남은 값들은 왼쪽으로 한 칸 씩 옮겨집니다.
v는 인덱스가 아닌 지울 값임을 기억하세요!
del()은 테이블을 순환하면서 안전하게 호출해 사용할 수 있습니다.

A={1,10,2,11,3,12}
FOR ITEM IN ALL(A) DO
IF (ITEM < 10) THEN DEL(A, ITEM) END
END
FOREACH(A, PRINT) -- 10,11,12
PRINT(A[3])       -- 12


all t

FOR 루프 안에서 테이블 안의 모든 값을 추가된 순서대로 돌아가며 참조하기 위해 씁니다 (테이블은 1-based 정수 인덱스를 씁니다). 

T = {11,12,13};
ADD(T,14)
ADD(T,"HI")
FOR V IN ALL(T) DO PRINT(V) END -- 11 12 13 14 HI
PRINT(#T) -- 5


foreach t f

테이블 t의 모든 값에 대해, 함수 f에 인자로 그 값만을 넣어서 호출합니다.

FOREACH(T, PRINT)


pairs t

FOR 루프 안에서 테이블 t 안의 모든 키-값 쌍들을 돌아가며 참조하기 위해 씁니다.
all()과는 달리 순서와 무관하게 모든 쌍들을 참조합니다.

T = {["HELLO"]=3, [10]="BLAH"}
T.BLUE = 5;
FOR K,V IN PAIRS(T) DO
PRINT("K: "..K.."  V:"..V)
END

Output:

K: 10  v:BLAH
K: HELLO  v:3
K: BLUE  v:5


--------------------------------------------------------------------------------------------
입력
--------------------------------------------------------------------------------------------

btn [i [p]]

플레이어 p의 버튼 i의 상태를 가져옴(p의 기본값은 0)
i: 0..5: 좌 우 상 하 o x
p: 플레이어 번호 0..7

인자가 주어지지 않았을 경우 플레이어 0, 1의 모든 버튼에 대한 비트필드를 반환
// P0: 비트 0..5  P1: 비트 8..13

플레이어 버튼 기본 매핑:
player 0: 화살표 키, Z,X / C,V / N,M
player 1: ESDF, LSHIFT,A / TAB,Q,E


btnp [i [p]]

기본적으로 btn()과 동일하지만 마지막 프레임에 눌리지 않은 버튼에 대해서만 참을 반환 
버튼을 15프레임 이상 누르고 있을 경우 이후 4 프레임마다 참을 반환합니다.

'계속 하시려면 버튼을 누르세요' 혹은 메뉴 아이템 이동의 구현에 유용하게 쓰일 수 있습니다.


--------------------------------------------------------------------------------------------
오디오
--------------------------------------------------------------------------------------------

sfx n [channel [offset]]

SFX n번(0..)을 channel 번 채널(0..3)에서 offset 번째 (0..31) 노트부터 재생
n을 -1로 설정해 해당 채널의 재생을 정지
n을 -2로 설정해 해당 채널의 루프를 정지
해당 채널에서 재생 중이던 SFX는 즉시 꺼짐

채널을 -1(기본값)로 설정해 현재 사용 중이지 않은 채널을 자동으로 선택
// 아무것도 재생되지 않을 경우, music()에 channel_mask를 부여하지 않아
// 현재 재생중인 음악이 모든 채널을 독차지한 것은 아닌지 확인해볼 것. (e.g. 1+2로 처음 두 채널을 선택) 


music [n [fade_len [channel_mask]]]

음악을 n번 패턴(0..63)부터 재생
n을 -1로 설정해 음악을 정지
fade_len (페이드 시간)의 단위는 ms (default: 0)
channel_mask로 어떤 채널에 음악을 할당할 것인지 설정
e.g. 채널 0..2 에서 재생시키려면: 1+2+4 = 7

음악 재생에 할당된 채널은 sfx()에서 채널 번호를 담아 요청했을 때만 효과음을 재생할 수 있습니다.


--------------------------------------------------------------------------------------------------------
맵
--------------------------------------------------------------------------------------------------------

mget x y
mset x y v

x,y의 맵 값을 가져오거나 v로 바꾸기

map cel_x cel_y sx sy cel_w cel_h [layer]

화면의 픽셀 sx, sy지점에서부터 맵의 일부 지역을 cel 단위를 써서 가져와 그리기
레이어가 명시되었을 경우 cel 중에서 해당 플래그가 켜져있는 cel만 그려짐
// 레이어는 비트필드 값입니다. 0x5는 비트 0과 2가 켜진 셀만 그릴 것입니다.
// 기본값은 모든 스프라이트

예외: 0번 스프라이트는 언제나 빈 이미지를 갖습니다.

e.g. map(0,0, 20,20, 4,2)
-> 맵의 0,0지점에서부터 4x2에 해당하는 영역을 화면의 20,20에 그립니다.

--------------------------------------------------------------------------------------------------------
메모리
--------------------------------------------------------------------------------------------------------

PICO-8에는 3가지의 메모리가 있습니다:

1. 베이스 ram (32k): 아래 레이아웃을 참조하세요. 다음의 함수들로 접근할 수 있습니다: peek() poke() memcpy() memset().
2. 카트 rom: 0x4300까지 베이스 RAM과 같은 레이아웃을 씁니다. reload()를 써서 베이스 RAM으로 복사할 수 있습니다.
3. lua ram (1MB): 컴파일된 프로그램과 변수들로 이루어져 있습니다. 막후 인물은 신경쓰지 마세요.

기술적 참고 사항: // 모르고 넘어가도 됩니다
편집기를 사용할 때 수정되는 데이터는 카트 rom의 데이터입니다. 하지만 spr(), sfx()를 포함한 몇몇 api 함수는 베이스 ram의 데이터만 다룹니다. PICO-8은 다음 3가지 경우에 자동으로 카트 rom을 베이스 ram으로 복사(reload()를 호출)합니다:

1. 카트리지를 불러올 때 (0.1.6 버전부터)
2. 카트리지를 구동할 때
3. 편집기를 나갈 때


:: 베이스 ram 메모리 레이아웃
0x0    gfx
0x1000 gfx2/맵2 (공유)
0x2000 맵
0x3000 gfx_props
0x3100 음악
0x3200 sfx
0x4300 유저 데이터
0x5e00 지속적persistent 카트 데이터 (256 바이트)
0x5f00 그리기 상태state
0x5f40 하드웨어 상태
0x5f80 gpio 핀 (128 바이트) // 개발 중
0x6000 화면 (8k)

'유저 데이터'에 부여된 특별한 의미는 없으며 memcpy(), peek(), poke()를 통해 원하는 대로 사용할 수 있습니다.
지속적 카트 데이터는 0x5e00..0x5eff에 연결되어 있고 cartdata()를 호출할 때만 여기에 저장됩니다.
컬러 포맷 (gfx/screen)은 바이트 당 2픽셀 씩입니다: 낮은 쪽 비트가 각 쌍의 왼쪽 픽셀을 인코딩합니다.
맵 포맷은 셀 당 1바이트이며, 이 바이트는 스프라이트 인덱스를 인코딩합니다.


peek addr
poke addr val

베이스 ram의 주소 addr에서 1바이트의 데이터를 쓰거나 읽습니다.
사용할 수 있는 주소대는 0x0..0x7fff
범위 밖에서 읽고 쓰기를 시도할 경우 폴트 발생

memcpy dest_addr source_addr len

베이스 ram의 source_addr에서 len바이트의 데이터를  dest_addr로 복사
복사 범위가 이전 범위를 덮어쓸 수 있음

reload dest_addr source_addr len [filename]

memcpy와 동일하나 카트 rom에서 복사
코드 섹션 ( >= 0x4300) 은 보호된 구역으로 읽을 수 없음
파일 이름이 명시되었을 경우 해당 카트리지에서 데이터를 불러옴

cstore dest_addr source_addr len [filename]

memcpy와 동일하나 베이스 ram에서 복사해서 카트 rom으로 붙임
cstore()는 cstore(0, 0, 0x4300)와 동일
카트 구성 툴을 쓰거나 맵/gfx 에디터를 통해서 맵/스프라이트 시트의 상태를 시각화할 때 쓸 수 있음
코드 섹션 ( >= 0x4300) 은 보호된 구역으로 읽을 수 없음

파일 이름이 명시되었을 경우 디스크 상의 명시된 카트리지에 바로 데이터가 쓰여집니다. 한 세션에서 최대 64 카트리지에 데이터를 쓸 수 있습니다.
'카트리지 데이터' 섹션에서 cstore 사용법에 대한 참고 사항을 확인하세요.


memset dest_addr val len

len바이트 길이의 값을 val로 설정
(꽤 빠름 -- 클리핑 없는 가로 스캔라인 등을 그릴 때 쓸 수 있음)


--------------------------------------------------------------------------------------------------------
수학
--------------------------------------------------------------------------------------------------------

max x y
min x y
mid x y z

인자값 중 최대, 최소, 중간 값을 반환
예를 들면 mid(7,5,10)은 7을 반환

flr x

x보다 작으면서 가장 가까운 정수를 반환 // x-(x%1) 
flr(4.1)  --> 4
flr(-2.3) --> -3.0


cos x
sin x

1.0을 원 한 바퀴라고 할 때 x의 코사인 값을 반환
사인 값은 화면 공간에 맞추기 위해 위 아래가 반전되어 반환됨
e.g. sin(0.25) 는 -1을 반환

y가 뒤집히지 않은 라디우스-기반 삼각함수를 쓰고 싶다면, 프로그램의 시작부에 다음 코드를 붙여넣으세요:

cos1 = cos function cos(angle) return cos1(angle/(3.1415*2)) end
sin1 = sin function sin(angle) return sin1(-angle/(3.1415*2)) end


atan2 dx dy

dx, dy 를 0..1 사이의 각도 값으로 바꿈
코사인/사인과 마찬가지로, 화면 공간에 맞추기 위해 각도는 반시계 방향으로 돌아감
e.g. atan(1, -1) 은 0.125을 반환 (↘)

sqrt x

x의 제곱근 값을 반환

abs x

x의 절대값을 반환

rnd x
0 <= n < x을 만족하는 난수 n을 반환
정수 값이 필요할 경우 flr(rnd(x))를 호출

srand x
난수 시드를 설정
카트리지를 시작할 때 자동으로 설정됨 

Bitwise operations

band x y
bor  x y
bxor x y
bnot x

shl  x y
shr  x y

// 시프트는 논리 시프트 (sign bit는 시프트 되지 않음)

--------------------------------------------------------------------------------------------------------
커스텀 메뉴 아이템
--------------------------------------------------------------------------------------------------------

menuitem index [label callback]

멈춤 메뉴에 항목을 추가

index 값은 1..5 사이여야 하며 각 메뉴 항목이 보여지는 순서를 결정
label 값은 최대 16글자 길이의 문자열이어야 함
callback 은 해당 메뉴를 선택했을 때 실행되는 함수

라벨이나 함수가 주어지지 않았을 경우, 해당 메뉴 항목은 제거됨

예:
menuitem(1, "restart puzzle", function() reset_puzzle() sfx(10) end)


--------------------------------------------------------------------------------------------------------
문자열
--------------------------------------------------------------------------------------------------------

s = "the quick brown fox"

-- 길이

print(#s)          --> 19


-- 문자열 합치기

print("three "..4) --> "three 4"


-- sub()로 부분열 찾아내기

print(sub(s,5,9))  --> "quick"
print(sub(s,5))  --> "quick brown fox"


--------------------------------------------------------------------------------------------
카트리지 데이터
--------------------------------------------------------------------------------------------

각 카트리지는 (카트 자체가 아닌) 사용자의 PICO-8에 64개(256바이트) 의 지속적 데이터를 보관할 수 있습니다. 이를 최고 점수나 플레이어 저장 데이터 등을 보관하는 간단한 방법으로 사용할 수 있습니다.

256바이트 이상의 데이터를 보관해야 할 경우에 cstore()를 이용해 카트리지에 직접 데이터를 쓸 수도 있습니다. 단점은 해당 데이터개 특정 버전의 카트리지에만 귀속된다는 것입니다. 이를테면, 게임이 업데이트 되면 세이브 데이터를 잃게 됩니다.

또 다른 대안으로, 다른 카트리지를 만들어서 cstore()로 저장하는 방법이 있습니다. 이 방법은 카트 교체swap를 요구하며, 따라서 약간 느립니다. 그리고 로컬 폴더에서 구동할 경우 데이터-카트 간의 찌꺼기litter를 남길 수 있습니다.


cartdata id

카트리지를 부를 때 한 번 호출하세요. id는 최대 64자의 문자열로, 다른 카트리지와 중복되지 않을 정도로 특별한 값이어야 합니다.

e.g. cartdata("zep_jelpi")

사용 가능한 문자는 a..z, 0..9, underscore (_) 입니다.

데이터 로드가 완료되었으면 참을 반환합니다.

cartdata는 카트리지를 실행할 때 1회 초과하여 호출할 수 없습니다.

cartdata id가 정해지면, 메모리 주소 0x5e00..0x5eff 가 영구 저장소permanent storage로서 할당되며, 이는 직접 혹은 dget/dset을 통해 접근할 수 있게 됩니다.


dget index

index(0..63)에 저장된 숫자를 가져옴
cartdata()를 호출한 이후에만 사용

dset index value

index(0..63)에 value 값을 저장
cartdata()를 호출한 이후에만 사용

쓰여진 데이터를 비울flush 필요는 없습니다 -- 데이터는 자동으로 영구 저장소에 저장되며, 직접 POKE()를 통해 불러와도 유지됩니다.


------------------------------------------------------------------------------------------------------------
버전 히스토리
------------------------------------------------------------------------------------------------------------

v0.1.8

추가: 60fps 지원
추가: 음악 추출
추가: 사용자 지정 GIF 길이 (최대 120초)
추가: -,+로 스프라이트 탭, sfx와 음악 패턴 사이를 이동
추가: sfx 편집기: home, end, pageup/down, mousewheel로 항목 간 이동
추가: <, > 이나 마우스 드래그로 sfx 속도 조절
추가: 마우스 가운데 버튼으로 스프라이트시트/맵 패닝pan
추가: splore 단축키: S
추가: 사전 설치된 BBS 카트 셀렉션 (INSTALL_GAMES로 설치)
추가: .p8.png로 저장할 때 라벨이 없을 경우 경고
추가: (OSX) ~/Library/Logs에 로그 저장 (Console.app으로 읽을 수 있음)
변경: CTRL-S로 bbs 카트에 저장할 수 없음
변경: dir()와 splore에서 .p8 파일만 표시함
변경: 명령어 히스토리 수를 256으로 증가
변경: 카트 구동 중일 때 exit() / shutdown()를 실행해도 아무런 변화 없음
고침: 메모리 사용량(stat(0))이 호스트 플랫폼에 따라 달라짐
고침: 현재 카트를 load()로 다시 부를 때 돌아가는 디스크 모양이 보여짐
고침: GIF 저장시 64x64 비율을 맞추지 않음 / 미러 모드
고침: 여러가지 여러 줄 주석 / 문자열 문제
고침: 비어있는 맵 셀이 mapdraw() 실행 시 cpu를 사용함
고침: mapdraw()로 맵 영역의 아래쪽 절반을 그릴 때 느려짐
고침: +=, : 연산자가 같은 줄에 있을 때 전처리preprocess 과정에서 의미가 달라짐
고침: 식별자가 언더스코어로 시작할 때 추가적인 토큰으로 처리됨
고침: 압축 코드 길이 제한이 초과하는 카트리지를 .png 포맷으로 저장할 때 아무 메세지 없이 조용하게 실패
고침: 스프라이트를 우클릭해도 현재 편집중인 스프라이트로 적용되지 않음
고침: (Windows) 코드를 붙여넣을 때 여백이 한 칸 추가됨
고침: spr()로 낮은 음수 대 좌표 영역에 그릴 때 자원 소모량이 높아짐
고침: 파이프 문자가 콜론 문자와 똑같이 취급됨
고침: (Raspberry Pi) 텍스트 입력 중 shift키를 누르면 문자가 추가됨
고침: 편집기 모드 버튼을 카트 런타임 때에도 클릭 가능
고침: .p8.png파일을 부를 때마다 라벨이 리셋되어서 다시 찍어야 함
고침: export() 실패 시에 실패를 알리지 않음
고침: 공유 메모리에서 mset()으로 바뀐 부분을 peek() / sget()으로 읽을 수 없음
고침: cstore()가 편집된 코드를 저장함
고침: 음악 재생 중 패턴이 바뀔 때마다 튀는 소리가 남

v0.1.7

추가: menuitem()
추가: 코드 내 사용 가능한 버튼 문자glyph (shift-L, R, U, D, X, O)
추가: 사용자 지정 가능한 데이터 디렉터리 (e.g. pico8 -home mydata)
추가: 웹 gpio 핀: 자바스크립트로 pico8_gpio[]를 읽고 쓰기
고침: SPLORE 검색이 리셋되지 않음
고침: Splore가 추가적으로 항목을 로드한 후에 33번째 카트를 스킵
고침: splore에서 로컬 이진 파일을 선택했을 때 크래시 발생
고침: 세미콜론을 리스트 혹은 문장의 구분자로 사용할 수 없음 
고침: html로 추출된 카트가 스스로 cstore를 할 수 없음


v0.1.6

추가: SPLORE 로컬 & bbs 카트리지 탐색기
추가: setmetatable(), cocreate(), coresume(), costatus(), yield()
추가: 카트 전환 혹은 카트에 쓰기 중일 때 돌아가는 카트 아이콘 표시
추가: 카트를 브라우저에서 플레이할 때를 위한 영구 저장소
추가: 조정 가능한 화면 비율 (-aspect 420 -> 1:1)
변경: Lua 메모리 제한: 1024k (기존 512k)
변경: 음악이 sfx에 손실을 당한 후being clobbered에도 이제 다시 정상적으로 재생됨
변경: SFX 속도가 8 이하일 때 아르페지오 속도를 두 배로
변경: 압축된 코드 길이 제한compressed code limit을 초과해도 .p8 형식으로 저장하는 것을 막지 않음
변경: spr() 소모 자원량을 반으로 줄여 map()과 비슷해지도록 함
변경: 16진수 소수 표기: 0x0.3 == 0x0.3000, (이전엔 0x0.0003)
변경: : 연산자를 토큰 수에 포함하지 않음 (.와 동일)
변경: cstore() 실행 시 디스크에 직접 기록
변경: cstore(), reload() 실행 시 읽거나 쓴 바이트 수를 반환
변경: 구동 중 save() 실행 시 아무 것도 하지 않음 (cstore()를 대신 사용할 것)
변경: 구동 중 load() 실행시 지정된 카트리지를 다시 로드하고 실행
고침: 오디오 믹서에서 음파 형태가 끊겨서 생기는 튀는 소리pops
고침: HTML5로 추출했을 때 Chrome에서 소리가 심각하게 끊김
고침: GIF로 추출할 때 화면 팔레트가 보이지 않음
고침: 키입력이 격렬해질 경우 트래커와 코드 편집기에서 읽기 행위 중복이 생김
고침: 주석 안의 +=가 프리프로세서preprocessor를 망가뜨림
고침: sspr()가 일부분만 선택되었을 때에도 동일한 cpu 사용량을 가짐
고침: 잘못된 인자 값을 cartdata()로 보냈을 때 크래시 발생
고침: 명령줄에서 EXPORT를 실행하려면 괄호와 따옴표를 넣어야 함


v0.1.5

추가: Raspberry Pi 빌드
추가: 플레이어 버튼의 키보드 설정 (KEYCONFIG) 
추가: 음악 트래커 선택 / 복사 / 붙여넣기
추가: 오디오 도구에서 한 단계 실행 취소
추가: 소리 편집기에서 주파수 미리 듣기
고침: 명령어 히스토리를 부팅 간에도 보존
고침: Sfx 추출기
고침: 주소 끝의 슬래시를 슬래시 두 개로 처리
고침: Windows에서 콘솔로 카트 부르기


v0.1.4d
v0.1.4c

고침: 외국어 문자가 다른 문자를 같이 삽입시킴
고침: 탭이 들어간 줄이 커서 위치와 디스플레이 영역을 망가뜨림

v0.1.4b

고침: OSX 커맨드키 조합

v0.1.4

추가: import("blah.png"), export("blah.png")로 스프라이트 시트 불러들이기/추출
추가: export("blah%d.wav")로 sfx 추출
추가: reload()와 cstore()에 외부 카트리지 인자
추가: 지속적Persistent 카트 데이터 (메모리 주소 0x5e00)
추가: 토큰 제한 표시를 클릭해서 토큰 & 글자수 제한 표시로 전환
추가: assert(), type()
추가: P로 멈추기
변경: 코드 글자수 제한: 64k (기존 32k)
변경: 지역 선언과 세미콜론이 토큰으로 간주되지 않음
변경: 괄호 한쌍과 블록 delimitations를 토큰 하나로 간주
변경: _update() 나 _draw() 만 있어도 메인 루프 진입 가능
변경: 코드 편집기에서 역슬래시를 허용
변경: info()가 현재(마지막으로 부르거나 저장한) 파일이름을 보고함
변경: html5 버전이 NO_DYNAMIC_EXECUTION 로 컴파일 됨 
변경: 한 세션에서 최대 64개의 파일까지만 cstore를 사용할 수 있음
변경: load() 실행 시 자동으로 카트의 데이터 섹션을 베이스 ram에 복사함
고침: 스프라이트를 Shift-드래그-복사 -> 붙여넣기 시 1x1 영역만 붙여넣음
고침: ".." 를 토큰 하나로 처리
고침: 트래커에서 . 대신 D 를 표시
고침: 여러 줄 주석
고침: 코드 길이가 문자 제한에 가까울 경우에 실행 시 크래시 발생
고침: 토큰 수 제한을 초과했을 때 어떤 명령어도 실행할 수 없음
고침: SFX 섹션에서 사용하지 않은 high bits가 .p8로 포맷할 때 저장되지 않음
고침: 카메라 위치의 메모리 매핑이 싱크가 맞지 않음
고침: Windows 인스톨러에서 pico8.txt 링크가 깨짐
고침: print()에 문자열이나 숫자가 아닌 인자를 넣었을 때 크래시 발생
고침: 여러줄의 문자열이나 확장 문자escape chars가 토큰 갯수와 print()에 영향을 줌
고침: 조이스틱의 left stick이 왼쪽 위를 향하고 있을 때 반응하지 않음
고침: Alt-F4를 누를 때 나가기 전에 스크린샷을 찍음
고침: 전체 화면 모드에서 스프라이트 편집기의 모드 버튼이 보이지 않음
고침: -sound 인자가 html5 버전에서 작동하지 않음 


v0.1.3

추가: 명령줄로 붙여넣기
고침: lua 표준 라이브러리에 접근할 수 있음
고침: 명령줄 로딩이 작동하지 않음
고침: 모든 트랙에 순환 설정이 되어있을 때 음악 패턴이 너무 빨리 끝남
고침: sfx 주소 대역에서 홀수 번째 바이트를 peek()했을 때 7번 비트가 마스킹 됨
고침: 코드 내에서 cstore 실행 후 다시 불렀을 때 아무런 효과가 없어야 함

v0.1.2

추가: html5 카트리지 추출기
추가: 카트리지 세이브 데이터 (64 고정 소수점 수)
추가: 8-플레이어 입력
추가: 데모 카트: COLLIDE, BUTTERFLY
추가: 커맨드라인 파라미터 // 카트 부르기, -run, 설정
추가: 펑션 키의 대안 (F6..F9을 F1..F4처럼 사용)
추가: pairs()
추가: 디버그를 위한 printh()
추가: 콘솔에서 탭으로 파일이름 자동완성
추가: 런타임 에러시 스택 트레이스stack trace 제공
변경: 음악 패턴 길이를 첫번째 비순환 채널의 길이로
변경: 노이즈 악기(6)의 저대역 화이트 노이즈low frequency white nose를 볼륨으로 조절 가능
변경: 스크린샷이 현재 해상도에서 윈도우 내의 전체 영역을 캡쳐
변경: del() 실행 시 테이블 내의 빈 공간을 막기 위해 남은 항목들을 앞으로 당김
변경: add(),del(),count(),all()이 더 이상 추가적인 필드를 저장하지 않음
변경: 문서에서 count() 삭제 -- 이제 legacy funcion으로 남아 있습니다. # 연산자를 대신 사용하세요.
변경: 윈도우가 활성화되었을 때에만 커서가 반짝임
변경: peek(), poke(), 이진 연산자(band()..)가 더 이상 function call overhead를 갖지 않음
변경: 노란색을 좀 더 따뜻하게
변경: 더 이상 맵 편집기에서 패닝한 후에 카메라 스내핑snapping이 발생하지 않음
고침: 0 이나 >= 32761 에서 sqrt()가 크래시
고침: 텍스트 편집기에서의 세미콜론 문자
고침: .p8 형식으로 저장할 때 긴 줄이 나눠짐 
고침: pget()이 카메라 위치의 영향을 받지 않음
고침: peek(), poke()를 사용 가능한 주소 이외의 범위에서 사용할 때 에러 메세지
고침: 색 찾아 바꾸기가 선택 영역으로부터 한 픽셀 밖까지 색칠
고침: 빈 음악 패턴을 재생하면 이후 음악 재생을 방해함
고침: 시작 시 유효하지 않은 sfx 편집 상태를 갖음
고침: 주파수 보기에서 악기를 범위 지정할 때 볼륨까지 같이 지정됨
고침: gif 녹화 속도가 일정치 않음
고침: 조이스틱 사용 시 키 매핑이 되지 않던 문제Unmapped joystick support
고침: 압축된 코드 크기가 가끔 압축 전보다 커짐
고침: 첫 번째 인자 값이 가장 작은 값이 아닐 경우 mid()를 구할 수 없음
고침: 코드 편집기에서 스크롤 휠을 굴리면 스프라이트/맵 확대 수준이 바뀜
고침: CTRL-R(빠른 구동) 시 명령어 모드에서 현재 줄 위로 그림
고침: 라벨 캡쳐(F7)가 스크린의 팔레트 상태를 반영하지 않음
고침: API 함수와 16진수 숫자의 하이라이팅
고침: 값을 줄이며 0까지 순환looping시킬 경우 1에서 순환을 멈춤
고침: nil값이 false로 출력됨
고침: 16진수 소수점 부
고침: 프레임을 스킵할 때 btnp()가 제대로 작동하지 않던 문제
고침: ctrl-r로 구동할 때 편집 모드를 잃어버리던 문제
고침: 트래커 노트의 엔트리 키가 매핑되어 피아노 형태의 레이아웃을 망침
고침: 일부 편집기 연산 이후에 공유 gfx/map 메모리의 싱크가 어긋남
고침: Alt-gr 문자 입력
고침: poke()를 이용해 16번째 이상의 엔트리에 화면 팔레트를 매핑할 수 있음
고침: 코드 편집기에서 shift를 이용해서 선택할 때 잘못된 선택 범위를 갖음
고침: 최상위 텍스트 너머로 드래그했을 때 선택 범위가 최하단까지 뒤집힘
고침: 파일 리스트의 끝에 중복 항목이 발생


v0.1.1

추가: 토큰 기반 코드 제한 (8192 토큰, 32k ascii 텍스트)
추가: 스프라이트 및 맵 편집기에서 freeform move, pan, selection
추가: Flood-fill 도구 (스프라이트, 맵)
추가: .GIF 저장
추가: CTRL-Stamp 로 투명도를 포함한 스탬프 찍기
추가: 맵과 스프라이트에서 한 단계 실행 취소 기능
추가: 2x2 브러시
추가: sqrt(), atan2()
추가: CTRL-S 로 빠른 저장
추가: CTRL-R 로 .p8 file을 다시 불러와 실행 (외부에서 텍스트를 편집할 때 유용)
추가: 덮어쓰거나 저장하지 않고 나갈 때 자동으로 백업 만들기
추가: 스프라이트 편집기에서 스크롤 휠로 확대/축소
추가: 사용자 정의 해상도 //  e.g. pico8 -width 580
추가: 문자열을 초록색으로 하이라이트
추가: ALT-click으로 우클릭을 대신하게 설정할 수 있음 (config.txt 참조)
추가: spr(), sspr()의 투명도를 조정하는 palt()
추가: info()
변경: load()로 불러오려는 파일이 존재하지 않을 경우 .p8.png, .png을 시도함
변경: 그리기 동작이 현재 선택중인 영역에만 적용됨
변경: 선택 영역이 존재할 경우 커서 이동 동작이 해당 영역 안에서만 작동함
변경: time() 제거
변경: 난수 시드가 카트 구동시 임의로 설정됨
변경: api 함수가 절대로 카트 rom을 직접 읽지 않음
변경: sspr()가 dw, dh 값으로 음수를 받을 수 있음
고침: 희소 테이블sparse table의 정수 인덱싱 실패
고침: 할당 연산자와 속기 형 if-then-else 작동 실패
고침: w0 == 128일 때 sspr() 작동 실패
고침: 카메라가 (0,0)이 아닐 때 원 그리기 실패
고침: CPU 독점hogging
고침: 노이즈 악기가 rnd() 순서에 영향을 끼침
고침: 프로그램 리셋 시에 오디오 시스템이 리셋되지 않음
고침: % 연산자가 가끔 음수 값에 대해 틀리게 작동
고침: 길이 연산자 (#)
고침: 제곱 연산자 (^)
고침: 화면 오른쪽과 아래쪽에서 줄이 잘리는 버그
고침: print()의 정수 표시 정밀도precision
고침: print()가 음수 y 값을 출력할 때 문제 발생
고침: 토큰화와 키워드 하이라이트
고침: 스프라이트 속성이 복사/붙여넣기 되지 않음
고침: sfx 0..32 만이 음악 패턴으로 사용될 수 있음
고침: .p8을 저장하고 불러올 때 코드 끝에 새 줄이 생김
고침: 코드 편집기에서 왼쪽 여백을 드래그로 선택 -> 전체 선택


v0.1.0

추가: 데모 카트: hello.p8 (install_demos로 설치)
추가: 어디서든 CTRL-R로 카트 실행/재시작
추가: gfx 편집기에서 a,s 로 색 선택하기
추가: 흑색 배경화면
추가: 일관적consistent CPU 수행 비용
추가: btn(), btnp()를 인자 없이 호출할 경우 비트필드를 반환
추가: fget(id)가 해당 스프라이트 플래그의 비트필드를 반환
변경: 일관성을 위해서 mapdraw()를 map()으로 바꿈
변경: 기본 sleep 시간을 5ms로 (랩탑 컴퓨터에서 CPU 사용이 더 쾌적함)
고침: 메모리 리미터
고침: 불안정한 선 및 원 그리기 기능
고침: sfx 편집기에서 shift-click 으로 볼륨 전체 적용하기
고침: 수 포맷팅이 과학적 기수법으로 표시됨
고침: 콘솔에서 오류 메세지가 잘림
고침: 문자 실행 취소text undo가 줄 번호를 바꿀 때 롤백 포인트를 저장
고침: print(str)가 이전 x값에 줄바꿈 문자carriage return를 추가함


v0.0.5

추가: help()
추가: Ctrl+F / Ctrl+G 로 텍스트 검색, 반복
추가: 코드 편집기 del 키
추가: IF 문의 한 줄 짜리 속기 표기
추가: 단항 연산자 += -= /= *= %=
추가: srand(), time(). rnd() 를 문서에 추가
추가: Ctrl+D 로 줄 복사
추가: 대화형 여러 페이지 파일 리스트 함수 ls()
추가: band() bor() bxor() bnot() shl() shr()
추가: 런타임 에러 줄 번호
추가: dir() (ls() 에일리어스)
변경: print()는 인자 없이 호출 되었을 때에만 오토 스크롤
변경: alt+up/down 로 함수 선언들로 건너 뛰기 (ctrl에서 변경)
변경: sspr() dw, dh의 기본값을 sw, sh로 적용
고침: .p8 format이나 디렉터리가 아닌 파일을 불러올 때 크래시 발생
고침: 여러가지 편집기 커서 위치 오류
고침: 코드를 보기 전 문법 오류가 발생할 경우 크래시 발생
고침: 재부팅 후 줄 바꿈 깨짐
고침: mkdir()를 인자 없이 부를 경우 "(null)" 디렉터리 생성
고침: 스크롤 휠로 코드보다 훨씬 위로 갈 수 있는 현상
고침: alt-f4로 빠르게 나가기


v0.0.4

추가: Jelpi 데모 카트
추가: 내부 카트 // install_demos()로 설치
추가: 조이스틱 지원
추가: 코드 편집기 실행 취소/재실행
추가: 코드 편집기 스크롤 휠
추가: LCTRL + UP/DOWN 로 코드 편집기에서 함수간 이동
추가: LALT + LEFT/RIGHT 로 편집기 모드 바꾸기
추가: btnp()
추가: 반복 샘플looping sample 반복 풀기 (편집기에서 a, 코드에서 sfx(-2, channel)로 사용)
변경: 프로그램 실행 중단시 음악 재생 중단
변경: 스프라이트 플래그 8개 허용
변경: 노이즈 악기의 저음부를 강화
고침: Home, end 키
고침: 스프라이트 플래그 4,5가 저장되지 않음
고침: mset()이 최상위 4 비트를 버림
고침: 긴 문자열 하이라이트시 크래시 발생


v0.0.3

추가: 팔레트 매핑 타입 1 (화면)
추가: 컬렉션(테이블)을 c={1,2,..} 처럼 초기화하기
추가: holdframe() // _draw(), update()에서 자동으로 사용
추가: 스프라이트 선택 영역 간의 선택, 작업
추가: 맵 선택, 스탬프 도구
추가: 모드 변경 시 모드 화면 보존
추가: 음악 재생을 위한 채널 마스크
추가: 실시간 음향 데이터를 위한 메모리 매핑
추가: .png 카트 형식
추가: 스프라이트 내비게이션 키 (-, +)
고침: 4-채널 소리 제한
고침: 자동 sfx 채널 선택 (채널 인덱스: -1)


v0.0.2

추가: 명령어 히스토리
추가: P2 키
추가: 부트 시퀀스
추가: 윈도우 및 64비트 리눅스 빌드
추가: 내부 API 함수의 CPU 사용량
추가: 개별적 음악 채널 인덱스와 mute 상태
추가: 메모리 매핑
추가: 스프라이트 편집기에서 색 찾아 바꾸기
추가: 스프라이트와 맵 구역의 복사/붙여넣기
향상: 즉각적 명령어 편집
향상: 편집기 커서 움직임
고침: 자동 오디오 채널 선택


v0.0.1 

첫 알파

 