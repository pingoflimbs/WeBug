-- PICO-8 API
-- 이 파일은 PICO-8의 주요 내장 함수를 정리한 것입니다.


function pico8_api_callback()
	
	----------------------------콜백 호출----------------------------	
	-- 다음의 특별 함수 3개는 사용자가 선언했을 경우 프로그램 실행 중에 호출됩니다:
	-- _init()
	-- 프로그램을 시작할 때 호출
	
	-- _update()
	-- 30fps에서 매 업데이트 시기마다 호출
	
	-- _draw()
	-- 매 번 프레임을 보여야 할 때마다 호출	
end


function pico8_api_gfx()

	----------------------------그래픽 설명----------------------------	
	-- PICO-8의 기본 해상도는 128×128픽셀입니다.	
	-- 좌표는 왼쪽 위 (0,0) 에서 시작해서 오른쪽으로 x, 아래로 y가 증가합니다.
	-- 화면의 최대 좌표는 (127, 127) 입니다.
	-- 좌표계는 다음과 같습니다.
	-- 		(0,0)       (127,0)
	-- 		┌─────────────┐
	-- 		│             │
	-- 		│             │
	-- 		└─────────────┘
	--  	(0,127)    (127,127)
		

	----------------------------그리기 설정----------------------------
	-- cls([색상값])
	-- 화면을 특정 색상으로 지움
	cls(COLOR.BLUE)	-- 화면을 파란색으로 지움
	cls() 			-- 기본색(0)으로 화면지움

	-- camera([X, Y])
	-- 호출 이후 모든 그리기함수의 좌표의 영점을 x,y로변경
	camera(64, 64)	-- 영점을 (64, 64)로 이동
	camera()		-- 카메라 리셋 (기본값 0,0)

	-- clip([X, Y, 폭, 높이])
	-- 호출 이후 모든 그리기함수 사용시 해당 사각 영역에만 draw 하게 함
	clip(64-8, 64-8, 16, 16) -- 화면 가운데 16px*16px 정사각형 부분만 draw
	clip()			-- clip 리셋


	----------------------------도형----------------------------	
	-- line(sX,sY, dX,dY, [색상])	
	-- 점0과 점1을 잇는 선을 그립니다
	line(10, 10, 100, 100) --기본컬러로 선 그리기
	line(12, 10, 102, 100, COLOR.RED) --빨간색으로 선 그리기

	-- rect(sX,sY, dX,dY, [색상])
	-- 사각형 그리기
	rect(10, 10, 104, 104) -- 기본컬러로 사각형 테두리 그리기
	rect(14, 14, 114, 114, COLOR.INDIGO) -- 인디고 색으로 사각형 테두리 그리기
	rectfill(30, 30, 48, 48, COLOR.LIGHT_GRAY) -- 연한 회색으로 사각형 채우기	

	-- circ(X, Y, 반지름, [색상]) 
	-- 원 그리기
	circ(64, 64, 8) -- 기본컬러로 원 그리기
	circ(64, 64, 6, COLOR.ORANGE) -- 오렌지색으로 원 그리기
	circfill(64, 64, 3, COLOR.ORANGE) -- 오렌지색으로 원 채우기

	-- oval(X0,Y0, X1,Y1, [색상]) 
	-- 타원 그리기
	oval(64,64, 90,90, 8) -- 기본컬러로 타원 그리기
	oval(64,64, 80,80, COLOR.ORANGE) -- 오렌지색으로 타원 그리기
	ovalfill(64,64, 10,10, COLOR.ORANGE) -- 오렌지색으로 타원 채우기




	----------------------------스프라이트 설명----------------------------	
	-- "스프라이트시트" 는 커다란 종이 (128x128 픽셀)
	-- "스프라이트슬롯" 은 종이위의 그려진 표의 한칸 (8x8픽셀)
	-- "스프라이트" 는 종이위의 한칸을 잘라낸 것
	-- 하단은 맵 시트
	-- 		┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
	-- 		│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15│	
	--		│ 16│ 17│ 18│ 19│ 20│ 21│ 22│ 23│ 24│ 25│ 26│ 27│ 28│ 29│ 30│ 31│
	--		│ 32│ 33│ 34│ 35│ 36│ 37│ 38│ 39│ 40│ 41│ 42│ 43│ 44│ 45│ 46│ 47│
	--		│ 48│ 49│ 50│ 51│ 52│ 53│ 54│ 55│ 56│ 57│ 58│ 59│ 60│ 61│ 62│ 63│
	--		│ 64│ 65│ 66│ 67│ 68│ 69│ 70│ 71│ 72│ 73│ 74│ 75│ 76│ 77│ 78│ 79│
	--		│ 80│ 81│ 82│ 83│ 84│ 85│ 86│ 87│ 88│ 89│ 90│ 91│ 92│ 93│ 94│ 95│
	--		│ 96│ 97│ 98│ 99│100│101│102│103│104│105│106│107│108│109│110│111│
	--		│112│113│114│115│116│117│118│119│120│121│122│123│124│125│126│127│	
	--		│128│129│130│131│132│133│134│135│136│137│138│139│140│141│142│143│
	--		│144│145│146│147│148│149│150│151│152│153│154│155│156│157│158│159│
	--		│160│161│162│163│164│165│166│167│168│169│170│171│172│173│174│175│
	--		│176│177│178│179│180│181│182│183│184│185│186│187│188│189│190│191│
	--		│192│193│194│195│196│197│198│199│200│201│202│203│204│205│206│207│
	--		│208│209│210│211│212│213│214│215│216│217│218│219│220│221│222│223│
	--		│224│225│226│227│228│229│230│231│232│233│234│235│236│237│238│239│
	--		│240│241│242│243│244│245│246│247│248│249│250│251│252│253│254│255│
	-- 		└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
	-- 스프라이트 는 8×8 픽셀 크기를 단위로 합니다.
	-- 스프라이트시트 는 128×128픽셀(= 16×16개 스프라이트)로 구성되어 있습니다.	
	-- 총 256개(0~255)의 스프라이트 슬롯이 있으며 이하와같습니다,
	-- 0~127번: 스프라이트 전용 영역
	-- 128~255번: 맵 데이터와 공유하는 영역	

	----------------------------스프라이트----------------------------	
	-- spr(스프라이트번호, X,Y, [우로몇칸,아래로몇칸], [좌우반전, 상하반전])
	-- "스프라이트"를 화면에 출력합니다.	
	spr(8, 20,20) 		-- 스프라이트 번호 8을 (20, 20) 위치에 그리기
	spr(1, 64,64, 4,4) 	-- 스프라이트 번호 1부터 우로4칸 아래로4칸을 (64, 64) 위치에 그리기
	
	-- sspr(sX,sY, sW,sH, dX,dY, dW,dH, [좌우반전, 상하반전])	
	-- "스프라이트시트"의 (sx, sy)에서 가로세로 픽셀(sw, sh)까지의 영역을 가져와서
	-- 화면의 (dx, dy)에서 가로세로 픽셀 (dw, dh)까지 늘려서 그립니다.
	sspr(0,0, 16,16, 64,0,32,32, true, false) -- 스프라이트시트의 (0,0)에서 16x16픽셀을 가져와서 화면(64,0)에서 32x32픽셀로 늘려서 그리기
	
	-- fset(스프라이트번호, 값)	
	-- 스프라이트의 플래그값을 설정하여 256개의 칸마다 8비트의 플래그를 설정할 수 있습니다.	
	-- 스프라이트에 이름을 부여해 프로그래밍을 편리하게 해줍니다.
	fset(2, 1+2+8)   -- 2번 스프라이트칸에 비트 0,1,3을 설정 (0b10000011 즉 11)

	-- fset(스프라이트번호, 몇번째비트, 설정여부)
	-- 스프라이트의 특정비트를 설정합니다.
	fset(3, 4, true) -- 3번스프라이트칸에 비트 4를 true로 설정 (0b00001000 즉 16)

	-- fget(스프라이트번호, [몇번째비트])
	-- 스프라이트의 플래그 값을 가져옵니다	
	value = fget(2) -- 2번스프라이트칸의 플래그값을 가져오기. 값은 11
	value = fget(3, 4) -- 3번스프라이트칸의 4번비트 가져오기. 값은 true





	---------------------------- 맵 ----------------------------
	-- mset(x, y, 플래그)
	-- 맵 좌표 (x, y)에 플래그값을 설정합니다
	mset(10,5, 1+2+8) -- 맵(10,5)에 비트 0,1,3을 설정 (0b10000011 즉 11)

	-- mget(x, y)
	-- 맵 좌표 (x, y)의 플래그 값을 읽어옵니다
	val = mget(10,5) -- 10,5 위치의 스프라이트 번호를 읽음

	-- map(tile_x, tile_y, [sx, sy], [tile_w, tile_h], [layers])
	-- 맵에서 (tile_x, tile_y) 위치부터 tile_w x tile_h 만큼의 타일을
	-- 화면의 (sx, sy) 픽셀 좌표에 그립니다
	-- layers 값을 주면 해당 플래그가 일치하는 타일만 그림	
	map(0,3, 20,20, 4,2) -- (0,3)부터 4x2 타일을 화면 (20,20)에 그림
	



	----------------------------텍스트----------------------------		
	-- print(텍스트, [X,Y], [색상])
	-- 문자를 출력합니다.
	print("WeBug!", 0,100, COLOR.WHITE) -- (0, 100) 위치에 흰색으로 문자 출력

	-- cursor(X,Y)
	-- 텍스트 커서를 이동합니다.
	cursor(30, 10) -- 다음 print("hi") 는 (30, 10) 위치에 출력
	cursor() -- 커서 리셋 (0,0)으로 이동


	-- type(값)
	-- 값의 타입을 리턴합니다	
	print(type(3)) --NUMBER
	print(type("3")) --STRING

	----------------------------색상----------------------------
	-- color([색상값])
	-- clr 등의 그리기 함수가 기본으로 사용할 색을 설정
	color(COLOR.RED)	-- 기본색 빨간색으로 설정
	color()				-- 기본색 (검정색 즉 0)으로 리셋

	-- pal(대상색, 바꿀색, [팔레트타입])
	-- 호출 이후 모든 그리기 함수에서 대상색 대신 바꿀색을 사용 (컬러 리매핑)	
	-- 팔레트 타입: (0: 새로그릴색에적용 , 1: 보이는색들에적용)	
	pal(COLOR.RED, COLOR.GREEN, 0) -- 이후로 사용되는 빨간색을 초록색으로 바꿈
	pal(COLOR.WHITE, COLOR.GREEN, 0) -- 현재화면의 횐색을 초록색으로 바꿈
	pal() -- 기본값으로 리셋 (모든 색을 원래 색으로 복원)

	-- palt([대상색, [투명여부]])	
	-- 대상 색을 투명하게, 또는 투명하지않게 설정
	palt(COLOR.BLACK) -- 검정색을 투명하게 설정
	palt(COLOR.WHITE, false) -- 흰색을 불투명하게 설정
	palt() -- 기본값으로 리셋 (모든 색을 불투명하게 복원)

	-- pget(X, Y)
	-- 픽셀 색상 가져오기
	-- return: 해당 위치의 색상 번호
	value = pget(64, 30) -- (64, 30) 좌표의 색상 가져오기

	-- pset(X, Y, 색상값)
	-- 픽셀 색상 설정. 즉 점찍기	
	pset(64, 30, COLOR.RED) -- (64, 30) 좌표에 빨간색 점 찍기

	-- sget(X, Y)
	-- 스프라이트시트상 좌표 색상 가져오기
	-- return: 해당 위치의 색상 번호
	value = sget(64, 34) -- (64, 34) 좌표의 색상 가져오기

	-- sset(X, Y, [색상])
	-- 스프라이트시트 상의 x, y 지점 픽셀의 색깔을 변경	
	sset(64, 34, COLOR.LIGHT_GRAY) -- (64, 34) 좌표에 연한 회색 점 찍기

	-- fillp(패턴)
	-- 4x4 의 픽셀 패턴을 설정합니다.
	-- RECT RECTFILL LINE 등의 그리기 함수에 적용됩니다.
	-- .-----------------------.
	-- | 16  | 15  | 14  | 13  |
	-- |-----|-----|-----|-----|
	-- |  12 | 11  | 10  |  9  |
	-- |-----|-----|-----|-----|
	-- |  8  |  7  |  6  |  5  |
	-- |-----|-----|-----|-----|
	-- |  4  |  3  |  2  |  1  |
	-- '-----------------------'	
	fill(0b1111000011110000) -- 4x4 픽셀 패턴을 설정합니다. 	
	-- 즉 이런 형태의 패턴을 만듭니다
	-- 1111
	-- 0000
	-- 1111
	-- 0000

end




function pico8_api_input()

	----------------------------버튼입력----------------------------		
	-- btn(버튼번호, [플레이어])	
	-- 버튼이 눌렸으면 1을, 아니면 0을 리턴합니다.
	pressed = btn(BTN.LEFT, 3) -- 왼쪽방향키 눌렸는지 확인 (플레이어 3)

	-- btnp(버튼번호, [플레이어])
	-- 기본적으로 btn()과 동일하지만 마지막 프레임에 눌리지 않은 버튼에 대해서만 true를 반환
	-- 버튼을 15프레임(0.5초) 이상 누르고 있을 경우 이후 4마다 true를 반환합니다.
	pressed = btnp(3, 2)
	
end




function pico8_api_sound()

	---------------------------- 사운드 ----------------------------
	-- sfx(n, [channel], [offset], [length])
	-- 사운드 번호 n번을 재생합니다 (0~63)
	-- channel: 0~3은 강제 채널 지정, -1은 자동, -2는 해당 사운드 중지
	-- offset: sfx 내에서 재생을 시작할 노트 위치 (0~31)
	-- length: 몇 개 노트를 재생할지 (기본값: 끝까지)

	sfx(3)           -- sfx 3번을 재생 (자동 채널 선택)
	sfx(3, 2)        -- sfx 3번을 채널 2에서 재생
	sfx(3, -2)       -- sfx 3번을 모든 채널에서 중지
	sfx(-1, 2)       -- 채널 2에서 재생 중인 어떤 소리든 중지
	sfx(-2, 2)       -- 채널 2에서 루프 중인 소리 "release"
	sfx(-1)          -- 모든 채널의 사운드를 중지
	sfx(-2)          -- 모든 루프 사운드를 해제

	-- music(n, [fade_len], [channel_mask])
	-- n번 패턴부터 음악을 재생합니다 (0~63)
	-- fade_len: 서서히 볼륨을 올리는데 걸리는 시간 (밀리초)
	-- channel_mask: 예약 채널 지정 (0=없음, 1=채널0, 2=채널1, 4=채널2, 8=채널3)
	music(0)              -- 패턴 0부터 음악 재생
	music(0, 1000)        -- 패턴 0을 1초 동안 페이드 인
	music(0, nil, 7)      -- 채널 0,1,2는 음악 전용 (0+1+2 = 1|2|4 = 7)
	music(-1)             -- 음악 중지

end







function pico8_api_table()
	---------------------------- 테이블 ----------------------------

	-- add(tbl, val, [index])
	-- 테이블 끝에 val을 추가합니다
	-- index를 지정하면 해당 위치에 삽입됩니다
	foo = {}
	add(foo, 10)
	add(foo, 20)
	add(foo, 15, 2) -- 2번째에 15 삽입
	print(foo[2]) -- 15


	-- del(tbl, val)
	-- 테이블에서 val과 같은 첫 값을 제거합니다
	-- 이후 값들은 한 칸씩 앞으로 당겨집니다
	a = {1, 2, 3, 4}
	del(a, 2) -- 값 2를 제거
	print(a[2]) -- 3


	-- deli(tbl, [i])
	-- 인덱스 i 위치의 값을 제거합니다
	-- i를 생략하면 마지막 값을 제거합니다
	t = {10, 20, 30}
	deli(t, 2) -- 2번째 값 제거 → {10, 30}
	deli(t)    -- 마지막 값 제거 → {10}


	-- count(tbl, [val])
	-- val이 없으면 테이블의 길이를 반환 (#tbl)
	-- val이 있으면 해당 값이 몇 번 나오는지 반환
	x = {1, 2, 2, 3}
	print(count(x))      -- 4
	print(count(x, 2))   -- 2


	-- all(tbl)
	-- for 루프에서 테이블을 순서대로 순회할 때 사용
	t = {1, 2, 3}
	add(t, 4)
	for v in all(t) do
	print(v)  -- 1 2 3 4
	end

	-- foreach(tbl, func)
	-- tbl의 각 항목에 대해 func(v)를 호출
	foreach({10, 20, 30}, print)
	-- 출력: 10 20 30

	-- pairs(tbl)
	-- 모든 키-값 쌍을 순회 (순서 보장 없음)
	d = {["a"]=1, [10]="hi"}
	d.test = 42
	for k,v in pairs(d) do
	print("k:"..k.." v:"..v)
	end
	-- 출력 예:
	-- k:10 v:hi
	-- k:a v:1
	-- k:test v:42

end




function pico8_api_math()

	----------------------------수학 관련 함수----------------------------	
	-- 내림
	value = flr(1.5) -- 1.5를 내림하여 1을 리턴
	
	-- 올림
	value = ceil(1.5) -- 1.5를 올림하여 2를 리턴

	-- 절댓값
	value = abs(1.5) -- 1.5의 절댓값을 리턴

	-- 최대값
	value = max(1, 5) -- 1과 5 중 큰 값을 리턴

	-- 최소값
	value = min(1, 5) -- 1과 5 중 작은 값을 리턴

	-- 중간값 반환
	value = mid(1, 3, 5) -- 중간값인 3 리턴

	-- sqrt(값)
	-- x의 제곱근	
    value = sqrt(16) -- 4.0 리턴


	----------------------------각도 관련 함수----------------------------	
	-- 사인
	value = sin(0.25) -- 사인값을 리턴 (0.25는 90도에 해당)

	-- 코사인
	value = cos(0.75) -- 코사인값을 리턴 (0.75는 270도에 해당)

	-- atan2(수평거리, 수직거리)
	-- dx, dy 를 0..1 사이의 각도 값으로 바꿈
	-- return: 두 점 사이의 각도 (0.0~1.0 = 0~360도)	
    value = atan2(1, 0) -- 0.25 (90도)
	

	----------------------------랜덤 함수----------------------------	
	-- rnd(최대값)
	-- 랜덤값. 소숫점까지 리턴
	value = rnd(100) -- 0.0~100.0 사이의 랜덤값 리턴
	value = abs(rnd(100)) -- 0~100 사이의 정수 랜덤값 리턴
	
	-- srand(랜덤seed)
	-- 랜덤 시드 설정
	srand(seed)
	
end



function pico8_api_memory()
	
	----------------------------메모리 맵----------------------------	
	-- 0x0    gfx
	-- 0x1000 gfx2/맵2 (공유)
	-- 0x2000 맵
	-- 0x3000 gfx_props
	-- 0x3100 음악
	-- 0x3200 sfx
	-- 0x4300 유저 데이터
	-- 0x5e00 지속적persistent 카트 데이터 (256 바이트)
	-- 0x5f00 그리기 상태state
	-- 0x5f40 하드웨어 상태
	-- 0x5f80 gpio 핀 (128 바이트) // 개발 중
	-- 0x6000 화면 (8k)
	
	----------------------------메모리 관련 함수----------------------------	
	-- peek(주소)
	-- 메모리에서 8비트 값을 읽어옵니다.
	value = peek(0x8000) -- 주소 0x8000에서 8비트 값 읽기
	value = peek4(0x8000) -- 주소 0x8000에서 32비트 값 읽기

	-- poke(주소, 값)
	-- 메모리에 8비트 값을 씁니다.
	poke(0x8000, 255) -- 주소 0x8000에 255 쓰기
	poke4(0x8000, 0x12345678) -- 주소 0x8000에 32비트 값 쓰기

	-- memcpy(대상주소, 원본주소, 길이)
	-- 메모리 블록을 복사합니다.
	memcpy(0x8000, 0x9000, 16) -- 주소 0x9000에서 16바이트를 주소 0x8000으로 복사

	-- memset(대상주소, 값, 길이)
	-- 메모리 블록을 초기화합니다.
	memset(0x8000, 255, 16) -- 주소 0x8000에 16바이트를 255로 초기화



end


function pico8_api_console()
	
	----------------------------디렉토리----------------------------	
	-- LOAD 파일이름
	-- 카트리지를 저장합니다.	

	-- SAVE 파일이름
	-- 카트리지를 불러오거나 저장합니다.
	-- CTRL+S로 저장할 수 있음

	-- FOLDER
	-- 탐색기에서 카트리지가 들어있는 폴더를 열기

	-- LS
	-- 현재 폴더의 모든 파일을 열거해서 보이기

	-- CD 디렉토리
	-- 디렉토리변경


	----------------------------단축키----------------------------	
	-- F1: 스크린샷
	-- F2: 카트리지png용 라벨이미지 저장
	-- F3: GIF 녹화시작
	-- F4: GIF 저장
	-- F5: 키보드커서	


	----------------------------시스템----------------------------	
	-- RUN 프로그램이름
	-- 프로그램을 시작 지점에서부터 실행
	-- 프로그램 내부에서 run() 으로 호출할 수 있음
	-- CTRL+R로 실행할 수 있음
	run("test/test.p8") -- test.p8 프로그램을 실행	

	-- RESUME
	-- 현재 카트리지 상태에서 프로그램을 실행
	resume()

	-- REBOOT
	-- 기계를 재부팅
	-- 새로운 프로젝트를 시작할 때 쓸 수 있음
	reboot()
	
	-- menuitem(인덱스, [이름], [콜백함수])
	-- pause 눌렀을때 나오는 메뉴에 항목을 추가합니다.
	pause()

	----------------------------디버그----------------------------		
	-- STAT [정보번호]
	-- 파라미터에따라 다음의 디버그 정보를 출력합니다.
	-- 		0  Memory usage (0..2048)
	-- 		1  CPU used since last flip (1.0 == 100% CPU)
	-- 		4  Clipboard contents (after user has pressed CTRL-V)
	-- 		6  Parameter string
	-- 		7  Current framerate
	--		30	(Boolean) True when a keypress is available
	--		31	(String) character returned by keyboard
	--		32	Mouse X	
	--		33	Mouse Y
	--		34	Mouse buttons (bitfield)
	--		36	Mouse wheel event
	--		38	Relative x movement (in host desktop pixels) -- requires flag 0x4
	--		39	Relative y movement (in host desktop pixels) -- requires flag 0x4
	-- 		46..49  Index of currently playing SFX on channels 0..3
	-- 		50..53  Note number (0..31) on channel 0..3
	-- 		54      Currently playing pattern index
	-- 		55      Total patterns played
	-- 		56      Ticks played on current pattern
	-- 		57      (Boolean) TRUE when music is playing
	-- 		80..85  UTC time: year, month, day, hour, minute, second
	-- 		90..95  Local time
	-- 		100     Current breadcrumb label, or nil
	-- 		110     Returns true when in frame-by-frame mode
	print(stat(1))

	-- assert(조건, 메시지)
	-- 조건이 false일 경우 메시지를 출력하고 프로그램을 종료합니다.
	assert(height >=0 and height <= 128, "height must be between 0 and 128")

	-- INFO
	-- 현재 카트리지에 대한 정보 출력:
	-- 코드 사이즈, 토큰, 압축 사이즈
	print(info())

	--time()
	-- 카트리지가 run 된 이후로 지난지 몇초인지 리턴합니다.
	time()


	----------------------------키보드마우스----------------------------
	-- poke(0x5F2D, 1+2+4) 를 설정하면 키보드마우스 쓸수있다	
	poke(0x5F2D, 0x1 + 0x2 + 0x4)	-- 0x1키마사용, 0x2마우스버튼, 0x4 마우스상대좌표	 
	value = stat(30) -- 키보드 입력이 있는지 확인
	value = stat(31) -- 키보드 입력이 있으면 해당 문자 리턴
	value = stat(32) -- 마우스 x좌표
	value = stat(33) -- 마우스 y좌표
	value = stat(34) -- 마우스 버튼 상태 (비트필드)
	value = stat(36) -- 마우스 휠 이벤트 (플래그)
	value = stat(38) -- 마우스 상대좌표 X
	value = stat(39) -- 마우스 상대좌표 Y

end
